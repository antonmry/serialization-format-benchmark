<!DOCTYPE html>
<html>
<head>
    <title>Serialization Format Benchmark Results</title>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    <style>
        body {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #f8f9fa;
        }
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
        }
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 40px;
        }
        .chart-container {
            width: 100%;
            height: 400px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            padding: 25px 20px;
            transition: box-shadow 0.3s ease;
        }
        .chart-container:hover {
            box-shadow: 0 6px 12px rgba(0,0,0,0.08);
        }
        @media (max-width: 1024px) {
            .charts-grid {
                grid-template-columns: 1fr;
            }
        }
        .loading {
            text-align: center;
            padding: 40px;
            font-size: 18px;
            color: #666;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .error {
            color: #d32f2f;
            padding: 20px;
            text-align: center;
            background-color: #ffebee;
            border-radius: 8px;
            margin: 20px 0;
            display: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .description {
            background-color: white;
            padding: 25px;
            border-radius: 8px;
            margin: 20px 0 40px;
            line-height: 1.6;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .description p {
            margin: 0 0 15px;
            color: #2c3e50;
        }
        .description ul {
            margin: 0 0 15px;
            padding-left: 25px;
        }
        .description li {
            margin-bottom: 10px;
            color: #34495e;
        }
        .description strong {
            color: #1a1a1a;
            font-weight: 600;
        }
        .description h2 {
            color: #2c3e50;
            font-size: 1.5em;
            margin-bottom: 15px;
        }
        .size-chart {
            margin-bottom: 60px;
        }
    </style>
</head>
<body>
    <h1>Serialization Format Benchmark Results</h1>

    <div class="description">
        <p>This visualization compares the performance of different serialization formats (Avro, Protobuf, Json, and Thrift) 
        across four different benchmarks:</p>
        <ul>
            <li><strong>Small Data Serialization:</strong> Performance when serializing small data objects</li>
            <li><strong>Big Data Serialization:</strong> Performance when serializing large data objects</li>
            <li><strong>Small Data Serialization + Deserialization:</strong> Combined performance for small data objects</li>
            <li><strong>Big Data Serialization + Deserialization:</strong> Combined performance for large data objects</li>
        </ul>
        <p>The y-axis shows operations per second (ops/s), higher values indicate better performance.</p>
    </div>

    <div id="loading" class="loading">Loading benchmark results...</div>
    <div id="error" class="error"></div>

    <div class="charts-grid">
        <div id="serializeSmall" class="chart-container"></div>
        <div id="serializeBig" class="chart-container"></div>
        <div id="serializeDeserializeSmall" class="chart-container"></div>
        <div id="serializeDeserializeBig" class="chart-container"></div>
    </div>

    <div class="description">
        <h2>Serialized Data Size Comparison</h2>
        <p>This chart compares the size of serialized data across different formats. A smaller size indicates better data compression, 
        which can be crucial for network transmission and storage efficiency.</p>
    </div>

    <div id="sizeComparison" class="chart-container size-chart"></div>

    <script>
        async function loadBenchmarkData() {
            try {
                const response = await fetch('benchmark-results.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();

                // Process and group benchmark data
                const benchmarks = {
                    serializeSmall: {},
                    serializeBig: {},
                    serializeDeserializeSmall: {},
                    serializeDeserializeBig: {},
                    sizeOfSerializedData: {
                        small: {},
                        big: {},
                        details: {} // Store complete information for each format
                    }
                };

                data.forEach(result => {
                    const benchmark = result.benchmark;
                    const score = result.primaryMetric.score;

                    // Extract and normalize format name
                    let format;
                    const lowerBenchmark = benchmark.toLowerCase();

                    if (lowerBenchmark.includes('avro')) format = 'Avro';
                    else if (lowerBenchmark.includes('proto')) format = 'Protobuf';
                    else if (lowerBenchmark.includes('json')) format = 'Json';
                    else if (lowerBenchmark.includes('thrift')) format = 'Thrift';
                    else {
                        console.warn('Unknown format in benchmark:', benchmark);
                        return;
                    }

                    if (!format) {
                        console.warn('Could not extract format from:', benchmark);
                        return;
                    }

                    if (benchmark.includes('serializeSmallThroughput') && !benchmark.includes('AndDeserialize')) {
                        benchmarks.serializeSmall[format] = score;
                    } else if (benchmark.includes('serializeBigThroughput') && !benchmark.includes('AndDeserialize')) {
                        benchmarks.serializeBig[format] = score;
                    } else if (benchmark.includes('serializeAndDeserializeSmallThroughput')) {
                        benchmarks.serializeDeserializeSmall[format] = score;
                    } else if (benchmark.includes('serializeAndDeserializeBigThroughput')) {
                        benchmarks.serializeDeserializeBig[format] = score;
                    } else if (benchmark.includes('sizeOfSerializedData')) {
                        const params = result.params;
                        const scopeLogsSize = params.scopeLogsSize;
                        const scopeType = params.scopeLogs;

                        // Store complete information
                        if (!benchmarks.sizeOfSerializedData.details[format]) {
                            benchmarks.sizeOfSerializedData.details[format] = {};
                        }
                        benchmarks.sizeOfSerializedData.details[format][scopeLogsSize] = {
                            score: score,
                            type: scopeType
                        };

                    }
                });

                return benchmarks;
            } catch (error) {
                console.error('Error loading benchmark data:', error);
                throw error;
            }
        }

        function createSizeChart(containerId, title, benchmarks) {
            const chart = echarts.init(document.getElementById(containerId));

            // Validate and process data
            if (!benchmarks?.sizeOfSerializedData?.details || 
                Object.keys(benchmarks.sizeOfSerializedData.details).length === 0) {
                console.error('No size comparison data available');
                return chart;
            }

            // Get all unique log sizes and sort them
            const allSizes = new Set();
            Object.values(benchmarks.sizeOfSerializedData.details).forEach(formatData => {
                Object.keys(formatData).forEach(size => allSizes.add(size));
            });
            const logSizes = Array.from(allSizes).sort((a, b) => parseInt(a) - parseInt(b));

            // Process data for each format
            const formats = Object.keys(benchmarks.sizeOfSerializedData.details);
            const formatData = {};
            formats.forEach(format => {
                formatData[format] = {};
                logSizes.forEach(size => {
                    if (benchmarks.sizeOfSerializedData.details[format][size]) {
                        formatData[format][size] = benchmarks.sizeOfSerializedData.details[format][size];
                    }
                });
            });

            const colors = ['#4299E1', '#48BB78', '#ECC94B', '#F56565', '#9F7AEA', '#ED8936', '#38B2AC'];

            // Create series for each log size
            const series = logSizes.map((size, index) => ({
                name: `${size} logs`,
                type: 'bar',
                data: formats.map(format => ({
                    value: formatData[format][size]?.score || 0,
                    itemStyle: {
                        color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{
                            offset: 0,
                            color: colors[index % colors.length]
                        }, {
                            offset: 1,
                            color: colors[index % colors.length] + '80'
                        }])
                    }
                }))
            }));

            const option = {
                animation: true,
                animationDuration: 1200,
                animationEasing: 'cubicInOut',
                title: {
                    text: title,
                    textStyle: {
                        fontSize: 15,
                        fontWeight: 600,
                        color: '#2c3e50'
                    },
                    left: 'center',
                    top: 0,
                    padding: [0, 0, 20, 0]
                },
                tooltip: {
                    trigger: 'axis',
                    axisPointer: {
                        type: 'shadow'
                    },
                    formatter: function(params) {
                        try {
                            const format = params[0].name;
                            let result = `<div style="font-weight:600;margin-bottom:8px;color:#2c3e50">${format}</div>`;
                            result += '<div style="color:#666;line-height:1.6">';

                            // Sort params by value for better readability
                            params.sort((a, b) => a.value - b.value);

                            params.forEach(param => {
                                if (param.value > 0) {
                                    result += `<div style="margin-bottom:6px;display:flex;align-items:center">
                                        <span style="display:inline-block;margin-right:8px;width:8px;height:8px;background:${param.color};border-radius:50%"></span>
                                        <span style="flex:1">
                                            <span style="color:#2c3e50;font-weight:500">${param.seriesName}:</span> 
                                            <span style="float:right">${param.value.toLocaleString()} bytes</span>
                                        </span>
                                    </div>`;
                                }
                            });

                            result += '</div>';
                            return result;
                        } catch (e) {
                            console.error('Error formatting tooltip:', e);
                            return 'Error displaying data';
                        }
                    },
                    backgroundColor: 'rgba(255, 255, 255, 0.98)',
                    borderColor: '#e2e8f0',
                    borderWidth: 1,
                    padding: [12, 16],
                    textStyle: {
                        color: '#2c3e50',
                        fontSize: 13
                    },
                    extraCssText: 'box-shadow: 0 4px 12px rgba(0,0,0,0.1); border-radius: 6px;'
                },
                legend: {
                    type: 'scroll',
                    top: '20px',
                    textStyle: {
                        color: '#2c3e50',
                        fontSize: 12,
                        fontWeight: 500
                    },
                    itemGap: 20,
                    itemWidth: 14,
                    itemHeight: 14,
                    pageButtonPosition: 'end',
                    pageButtonItemGap: 5,
                    pageButtonGap: 5
                },
                grid: {
                    left: '8%',
                    right: '8%',
                    top: '60px',
                    bottom: '40px',
                    containLabel: true
                },
                xAxis: {
                    type: 'category',
                    data: formats,
                    axisLabel: {
                        color: '#2c3e50',
                        fontSize: 12
                    },
                    axisLine: {
                        lineStyle: {
                            color: '#e0e6ed'
                        }
                    }
                },
                yAxis: {
                    type: 'value',
                    name: 'Size (bytes)',
                    nameLocation: 'middle',
                    nameGap: 50,
                    axisLabel: {
                        formatter: value => value.toLocaleString(),
                        color: '#2c3e50'
                    },
                    splitLine: {
                        lineStyle: {
                            type: 'dashed',
                            color: '#e0e6ed'
                        }
                    }
                },
                series: series.map(s => ({
                    ...s,
                    barGap: '8%',
                    barCategoryGap: '20%',
                    barWidth: '20%',
                    itemStyle: {
                        ...s.data[0].itemStyle,
                        borderRadius: [6, 6, 0, 0],
                        opacity: 0.9
                    },
                    label: {
                        show: false
                    },
                    emphasis: {
                        itemStyle: {
                            shadowBlur: 12,
                            shadowOffsetY: 4,
                            shadowColor: 'rgba(0,0,0,0.2)',
                            opacity: 1
                        },
                        focus: 'series'
                    }
                }))
            };

            chart.setOption(option);
            return chart;
        }

        function createChart(containerId, title, data) {
            const chart = echarts.init(document.getElementById(containerId));

            const formats = Object.keys(data);
            const colors = ['#4299E1', '#48BB78', '#F6AD55', '#F56565'];

            const option = {
                animation: true,
                animationDuration: 1200,
                animationEasing: 'cubicInOut',
                animationDelay: function (idx) {
                    return idx * 100;
                },
                title: {
                    text: title,
                    textStyle: {
                        fontSize: 15,
                        fontWeight: 600,
                        color: '#2c3e50',
                        lineHeight: 24
                    },
                    left: 'center',
                    top: 0,
                    padding: [0, 0, 20, 0],
                    backgroundColor: 'rgba(255,255,255,0.8)',
                    borderRadius: 4,
                    width: '90%',
                    textAlign: 'center'
                },
                color: colors,
                tooltip: {
                    trigger: 'item',
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    borderColor: '#eee',
                    borderWidth: 1,
                    padding: [10, 15],
                    textStyle: {
                        color: '#2c3e50',
                        fontSize: 13
                    },
                    formatter: function(params) {
                        return `<div style="font-weight:600;margin-bottom:4px">${params.name}</div>
                                <div style="color:#666">
                                    <span style="display:inline-block;margin-right:8px;width:10px;height:10px;background:${params.color};border-radius:50%"></span>
                                    ${params.value.toLocaleString()} ops/s
                                </div>`;
                    },
                    extraCssText: 'box-shadow: 0 0 8px rgba(0,0,0,0.1); border-radius: 4px;'
                },
                grid: {
                    left: '12%',
                    right: '5%',
                    top: '60px',
                    bottom: '40px',
                    containLabel: true
                },
                xAxis: {
                    type: 'category',
                    data: formats,
                    axisLabel: {
                        interval: 0,
                        color: '#2c3e50',
                        fontSize: 12,
                        fontWeight: 500
                    },
                    axisLine: {
                        lineStyle: {
                            color: '#e0e6ed',
                            width: 2
                        }
                    },
                    axisTick: {
                        show: false
                    }
                },
                yAxis: {
                    type: 'value',
                    name: 'Operations per second',
                    nameLocation: 'middle',
                    nameGap: 55,
                    nameTextStyle: {
                        color: '#2c3e50',
                        fontSize: 13,
                        fontWeight: 500,
                        padding: [0, 0, 25, 0]
                    },
                    axisLabel: {
                        formatter: value => value.toLocaleString(),
                        color: '#2c3e50',
                        fontSize: 11,
                        margin: 12
                    },
                    splitLine: {
                        lineStyle: {
                            color: '#f0f2f5',
                            width: 2
                        }
                    },
                    axisLine: {
                        show: true,
                        lineStyle: {
                            color: '#e0e6ed',
                            width: 2
                        }
                    },
                    axisTick: {
                        show: false
                    }
                },
                series: [{
                    type: 'bar',
                    data: formats.map(format => data[format]),
                    barMaxWidth: '50%',
                    itemStyle: {
                        borderRadius: [8, 8, 0, 0],
                        color: function(params) {
                            return new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                { offset: 0, color: colors[params.dataIndex] },
                                { offset: 1, color: colors[params.dataIndex] + '90' }
                            ]);
                        }
                    },
                    label: {
                        show: true,
                        position: 'top',
                        distance: 8,
                        formatter: value => value.value.toLocaleString(),
                        fontSize: 12,
                        fontWeight: 600,
                        color: '#2c3e50',
                        backgroundColor: 'rgba(255, 255, 255, 0.8)',
                        padding: [4, 8],
                        borderRadius: 4,
                        animation: true,
                        animationDuration: 1000,
                        animationDelay: function(idx) {
                            return idx * 100 + 300;
                        }
                    },
                    emphasis: {
                        itemStyle: {
                            color: function(params) {
                                return new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: colors[params.dataIndex] },
                                    { offset: 1, color: colors[params.dataIndex] }
                                ]);
                            },
                            shadowBlur: 20,
                            shadowOffsetY: 4,
                            shadowColor: 'rgba(0,0,0,0.2)'
                        }
                    }
                }]
            };

            chart.setOption(option);
            return chart;
        }

        // Load and display data
        const loadingEl = document.getElementById('loading');
        const errorEl = document.getElementById('error');
        const charts = [];

        loadBenchmarkData()
            .then(async benchmarks => {
                loadingEl.style.display = 'none';

                // Create charts with delay
                const createChartWithDelay = (id, title, data, delay) => {
                    return new Promise(resolve => {
                        setTimeout(() => {
                            const chart = createChart(id, title, data);
                            charts.push(chart);
                            resolve();
                        }, delay);
                    });
                };

                // Initialize charts sequentially with delays
                try {
                    await createChartWithDelay(
                        'serializeSmall',
                        'Small Data Serialization Performance',
                        benchmarks.serializeSmall,
                        0
                    );

                    await createChartWithDelay(
                        'serializeBig',
                        'Big Data Serialization Performance',
                        benchmarks.serializeBig,
                        200
                    );

                    await createChartWithDelay(
                        'serializeDeserializeSmall',
                        'Small Data Serialization + Deserialization Performance',
                        benchmarks.serializeDeserializeSmall,
                        400
                    );

                    await createChartWithDelay(
                        'serializeDeserializeBig',
                        'Big Data Serialization + Deserialization Performance',
                        benchmarks.serializeDeserializeBig,
                        600
                    );

                    // Debug log before creating size chart
                    console.log('Creating size chart with data:', {
                        small: benchmarks.sizeOfSerializedData.small,
                        big: benchmarks.sizeOfSerializedData.big
                    });

                    const sizeChart = createSizeChart(
                        'sizeComparison',
                        'Serialized Data Size',
                        benchmarks
                    );
                    charts.push(sizeChart);
                } catch (error) {
                    console.error('Error creating charts:', error);
                    errorEl.textContent = 'Error creating charts. Please try again later.';
                    errorEl.style.display = 'block';
                }

                // Handle window resize for all charts
                window.addEventListener('resize', () => {
                    charts.forEach(chart => chart.resize());
                });
            })
            .catch(error => {
                loadingEl.style.display = 'none';
                errorEl.textContent = 'Error loading benchmark data. Please try again later.';
                errorEl.style.display = 'block';
            });
    </script>
</body>
</html>
