<!DOCTYPE html>
<html>
<head>
    <title>Serialization Format Benchmark Results</title>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    <style>
        body {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #f8f9fa;
        }
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
        }
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 40px;
        }
        .chart-container {
            width: 100%;
            height: 400px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            padding: 25px 20px;
            transition: box-shadow 0.3s ease;
        }
        .chart-container:hover {
            box-shadow: 0 6px 12px rgba(0,0,0,0.08);
        }
        @media (max-width: 1024px) {
            .charts-grid {
                grid-template-columns: 1fr;
            }
        }
        .loading {
            text-align: center;
            padding: 40px;
            font-size: 18px;
            color: #666;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .error {
            color: #d32f2f;
            padding: 20px;
            text-align: center;
            background-color: #ffebee;
            border-radius: 8px;
            margin: 20px 0;
            display: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .description {
            background-color: white;
            padding: 25px;
            border-radius: 8px;
            margin: 20px 0 40px;
            line-height: 1.6;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .description p {
            margin: 0 0 15px;
            color: #2c3e50;
        }
        .description ul {
            margin: 0 0 15px;
            padding-left: 25px;
        }
        .description li {
            margin-bottom: 10px;
            color: #34495e;
        }
        .description strong {
            color: #1a1a1a;
            font-weight: 600;
        }
        .description h2 {
            color: #2c3e50;
            font-size: 1.5em;
            margin-bottom: 15px;
        }
        .size-chart {
            margin-bottom: 60px;
        }
    </style>
</head>
<body>
    <h1>Serialization Format Benchmark Results</h1>

    <div class="description">
        <p>This visualization compares the performance of different serialization formats (Avro, Protobuf, Json, and Thrift) 
        across four different benchmarks:</p>
        <ul>
            <li><strong>Small Data Serialization:</strong> Performance when serializing small data objects</li>
            <li><strong>Big Data Serialization:</strong> Performance when serializing large data objects</li>
            <li><strong>Small Data Serialization + Deserialization:</strong> Combined performance for small data objects</li>
            <li><strong>Big Data Serialization + Deserialization:</strong> Combined performance for large data objects</li>
        </ul>
        <p>The y-axis shows operations per second (ops/s), higher values indicate better performance.</p>
    </div>

    <div id="loading" class="loading">Loading benchmark results...</div>
    <div id="error" class="error"></div>

    <div class="charts-grid">
        <div id="serializeSmall" class="chart-container"></div>
        <div id="serializeBig" class="chart-container"></div>
        <div id="serializeDeserializeSmall" class="chart-container"></div>
        <div id="serializeDeserializeBig" class="chart-container"></div>
    </div>

    <div class="description">
        <h2>Serialized Data Size Comparison</h2>
        <p>This chart compares the size of serialized data across different formats. A smaller size indicates better data compression, 
        which can be crucial for network transmission and storage efficiency.</p>
    </div>

    <div id="sizeComparison" class="chart-container size-chart"></div>

    <script>
        async function loadBenchmarkData() {
            try {
                const response = await fetch('benchmark-results.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();

                // Process and group benchmark data
                const benchmarks = {
                    serializeSmall: {},
                    serializeBig: {},
                    serializeDeserializeSmall: {},
                    serializeDeserializeBig: {},
                    sizeOfSerializedData: {
                        small: {},
                        big: {},
                        details: {} // Store complete information for each format
                    }
                };

                data.forEach(result => {
                    const benchmark = result.benchmark;
                    const score = result.primaryMetric.score;

                    // Extract and normalize format name
                    let format;
                    const lowerBenchmark = benchmark.toLowerCase();

                    if (lowerBenchmark.includes('avro')) format = 'Avro';
                    else if (lowerBenchmark.includes('proto')) format = 'Protobuf';
                    else if (lowerBenchmark.includes('json')) format = 'Json';
                    else if (lowerBenchmark.includes('thrift')) format = 'Thrift';
                    else {
                        console.warn('Unknown format in benchmark:', benchmark);
                        return;
                    }

                    if (!format) {
                        console.warn('Could not extract format from:', benchmark);
                        return;
                    }

                    if (benchmark.includes('serializeSmallThroughput') && !benchmark.includes('AndDeserialize')) {
                        benchmarks.serializeSmall[format] = score;
                    } else if (benchmark.includes('serializeBigThroughput') && !benchmark.includes('AndDeserialize')) {
                        benchmarks.serializeBig[format] = score;
                    } else if (benchmark.includes('serializeAndDeserializeSmallThroughput')) {
                        benchmarks.serializeDeserializeSmall[format] = score;
                    } else if (benchmark.includes('serializeAndDeserializeBigThroughput')) {
                        benchmarks.serializeDeserializeBig[format] = score;
                    } else if (benchmark.includes('sizeOfSerializedData')) {
                        const params = result.params;
                        const scopeLogsSize = params.scopeLogsSize;
                        const scopeType = params.scopeLogs;

                        // Store complete information
                        if (!benchmarks.sizeOfSerializedData.details[format]) {
                            benchmarks.sizeOfSerializedData.details[format] = [];
                        }
                        benchmarks.sizeOfSerializedData.details[format].push({
                            score: score,
                            size: scopeLogsSize,
                            type: scopeType
                        });

                        // Also store in the original structure
                        if (scopeType === 'SMALL') {
                            benchmarks.sizeOfSerializedData.small[format] = score;
                        } else if (scopeType === 'BIG') {
                            benchmarks.sizeOfSerializedData.big[format] = score;
                        }

                    }
                });

                return benchmarks;
            } catch (error) {
                console.error('Error loading benchmark data:', error);
                throw error;
            }
        }

        function createSizeChart(containerId, title, benchmarks) {
            const chart = echarts.init(document.getElementById(containerId));

            // Validate and process data
            if (!benchmarks?.sizeOfSerializedData?.details || 
                Object.keys(benchmarks.sizeOfSerializedData.details).length === 0) {
                console.error('No size comparison data available');
                return chart;
            }

            // Process data to show one value per format
            const formatData = {};
            Object.entries(benchmarks.sizeOfSerializedData.details).forEach(([format, data]) => {
                if (!data || data.length === 0) {
                    console.warn(`No data available for format: ${format}`);
                    return;
                }
                formatData[format] = {
                    score: data[0].score,
                    size: data[0].size
                };
            });

            // Sort formats by size (ascending)
            const formats = Object.entries(formatData)
                .sort(([,a], [,b]) => a.score - b.score)
                .map(([format]) => format);

            const scores = formats.map(f => formatData[f].score);
            const minScore = scores[0]; // First score is the minimum after sorting

            const colors = ['#3182CE', '#38A169', '#DD6B20', '#E53E3E'];

            const option = {
                animation: true,
                animationDuration: 1200,
                animationEasing: 'cubicInOut',
                title: {
                    text: title,
                    textStyle: {
                        fontSize: 15,
                        fontWeight: 600,
                        color: '#2c3e50'
                    },
                    left: 'center',
                    top: 0,
                    padding: [0, 0, 20, 0]
                },
                tooltip: {
                    trigger: 'axis',
                    axisPointer: {
                        type: 'shadow'
                    },
                    formatter: function(params) {
                        try {
                            const format = params[0].name;
                            const data = formatData[format];
                            const rank = formats.indexOf(format) + 1;
                            const percentageDiff = ((data.score - minScore) / minScore * 100).toFixed(1);

                            return `<div style="font-weight:600;margin-bottom:8px">${format}</div>
                                   <div style="color:#666;line-height:1.6">
                                     <div style="margin-bottom:4px">
                                        <span style="color:#2c3e50">Rank:</span> ${rank} of ${formats.length}
                                     </div>
                                     <div style="margin-bottom:4px">
                                        <span style="color:#2c3e50">Size:</span> ${data.score.toLocaleString()} bytes
                                     </div>
                                     <div style="color:#666;margin-top:4px">Uses ${percentageDiff}% more bytes than ${formats[0]}</div>
                                   </div>`;
                        } catch (e) {
                            console.error('Error formatting tooltip:', e);
                            return 'Error displaying data';
                        }
                    },
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    borderColor: '#eee',
                    borderWidth: 1,
                    padding: [10, 15],
                    textStyle: {
                        color: '#2c3e50',
                        fontSize: 13
                    },
                    extraCssText: 'box-shadow: 0 0 8px rgba(0,0,0,0.1); border-radius: 4px;'
                },
                grid: {
                    left: '10%',
                    right: '5%',
                    top: '60px',
                    bottom: '40px',
                    containLabel: true
                },
                xAxis: {
                    type: 'category',
                    data: formats,
                    axisLabel: {
                        color: '#2c3e50',
                        fontSize: 12
                    },
                    axisLine: {
                        lineStyle: {
                            color: '#e0e6ed'
                        }
                    }
                },
                yAxis: {
                    type: 'value',
                    name: 'Size (bytes)',
                    nameLocation: 'middle',
                    nameGap: 50,
                    axisLabel: {
                        formatter: value => value.toLocaleString(),
                        color: '#2c3e50'
                    },
                    splitLine: {
                        lineStyle: {
                            type: 'dashed',
                            color: '#e0e6ed'
                        }
                    }
                },
                series: [{
                    type: 'bar',
                    data: formats.map((format, index) => ({
                        value: formatData[format].score,
                        itemStyle: {
                            color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{
                                offset: 0,
                                color: colors[index]
                            }, {
                                offset: 1,
                                color: colors[index] + '90'
                            }]),
                            borderRadius: [6, 6, 0, 0]
                        }
                    })),
                    barWidth: '50%',
                    label: {
                        show: true,
                        position: 'top',
                        formatter: function(params) {
                            const data = formatData[params.name];
                            return data.score.toLocaleString();
                        },
                        fontSize: 12,
                        color: '#2c3e50',
                        distance: 10
                    },
                    emphasis: {
                        itemStyle: {
                            shadowBlur: 10,
                            shadowColor: 'rgba(0,0,0,0.2)'
                        }
                    }
                }]
            };

            chart.setOption(option);
            return chart;
        }

        function createChart(containerId, title, data) {
            const chart = echarts.init(document.getElementById(containerId));

            const formats = Object.keys(data);
            const colors = ['#4299E1', '#48BB78', '#F6AD55', '#F56565'];

            const option = {
                animation: true,
                animationDuration: 1200,
                animationEasing: 'cubicInOut',
                animationDelay: function (idx) {
                    return idx * 100;
                },
                title: {
                    text: title,
                    textStyle: {
                        fontSize: 15,
                        fontWeight: 600,
                        color: '#2c3e50',
                        lineHeight: 24
                    },
                    left: 'center',
                    top: 0,
                    padding: [0, 0, 20, 0],
                    backgroundColor: 'rgba(255,255,255,0.8)',
                    borderRadius: 4,
                    width: '90%',
                    textAlign: 'center'
                },
                color: colors,
                tooltip: {
                    trigger: 'item',
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    borderColor: '#eee',
                    borderWidth: 1,
                    padding: [10, 15],
                    textStyle: {
                        color: '#2c3e50',
                        fontSize: 13
                    },
                    formatter: function(params) {
                        return `<div style="font-weight:600;margin-bottom:4px">${params.name}</div>
                                <div style="color:#666">
                                    <span style="display:inline-block;margin-right:8px;width:10px;height:10px;background:${params.color};border-radius:50%"></span>
                                    ${params.value.toLocaleString()} ops/s
                                </div>`;
                    },
                    extraCssText: 'box-shadow: 0 0 8px rgba(0,0,0,0.1); border-radius: 4px;'
                },
                grid: {
                    left: '12%',
                    right: '5%',
                    top: '60px',
                    bottom: '40px',
                    containLabel: true
                },
                xAxis: {
                    type: 'category',
                    data: formats,
                    axisLabel: {
                        interval: 0,
                        color: '#2c3e50',
                        fontSize: 12,
                        fontWeight: 500
                    },
                    axisLine: {
                        lineStyle: {
                            color: '#e0e6ed',
                            width: 2
                        }
                    },
                    axisTick: {
                        show: false
                    }
                },
                yAxis: {
                    type: 'value',
                    name: 'Operations per second',
                    nameLocation: 'middle',
                    nameGap: 55,
                    nameTextStyle: {
                        color: '#2c3e50',
                        fontSize: 13,
                        fontWeight: 500,
                        padding: [0, 0, 25, 0]
                    },
                    axisLabel: {
                        formatter: value => value.toLocaleString(),
                        color: '#2c3e50',
                        fontSize: 11,
                        margin: 12
                    },
                    splitLine: {
                        lineStyle: {
                            color: '#f0f2f5',
                            width: 2
                        }
                    },
                    axisLine: {
                        show: true,
                        lineStyle: {
                            color: '#e0e6ed',
                            width: 2
                        }
                    },
                    axisTick: {
                        show: false
                    }
                },
                series: [{
                    type: 'bar',
                    data: formats.map(format => data[format]),
                    barMaxWidth: '50%',
                    itemStyle: {
                        borderRadius: [8, 8, 0, 0],
                        color: function(params) {
                            return new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                { offset: 0, color: colors[params.dataIndex] },
                                { offset: 1, color: colors[params.dataIndex] + '90' }
                            ]);
                        }
                    },
                    label: {
                        show: true,
                        position: 'top',
                        distance: 8,
                        formatter: value => value.value.toLocaleString(),
                        fontSize: 12,
                        fontWeight: 600,
                        color: '#2c3e50',
                        backgroundColor: 'rgba(255, 255, 255, 0.8)',
                        padding: [4, 8],
                        borderRadius: 4,
                        animation: true,
                        animationDuration: 1000,
                        animationDelay: function(idx) {
                            return idx * 100 + 300;
                        }
                    },
                    emphasis: {
                        itemStyle: {
                            color: function(params) {
                                return new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: colors[params.dataIndex] },
                                    { offset: 1, color: colors[params.dataIndex] }
                                ]);
                            },
                            shadowBlur: 20,
                            shadowOffsetY: 4,
                            shadowColor: 'rgba(0,0,0,0.2)'
                        }
                    }
                }]
            };

            chart.setOption(option);
            return chart;
        }

        // Load and display data
        const loadingEl = document.getElementById('loading');
        const errorEl = document.getElementById('error');
        const charts = [];

        loadBenchmarkData()
            .then(async benchmarks => {
                loadingEl.style.display = 'none';

                // Create charts with delay
                const createChartWithDelay = (id, title, data, delay) => {
                    return new Promise(resolve => {
                        setTimeout(() => {
                            const chart = createChart(id, title, data);
                            charts.push(chart);
                            resolve();
                        }, delay);
                    });
                };

                // Initialize charts sequentially with delays
                try {
                    await createChartWithDelay(
                        'serializeSmall',
                        'Small Data Serialization Performance',
                        benchmarks.serializeSmall,
                        0
                    );

                    await createChartWithDelay(
                        'serializeBig',
                        'Big Data Serialization Performance',
                        benchmarks.serializeBig,
                        200
                    );

                    await createChartWithDelay(
                        'serializeDeserializeSmall',
                        'Small Data Serialization + Deserialization Performance',
                        benchmarks.serializeDeserializeSmall,
                        400
                    );

                    await createChartWithDelay(
                        'serializeDeserializeBig',
                        'Big Data Serialization + Deserialization Performance',
                        benchmarks.serializeDeserializeBig,
                        600
                    );

                    // Debug log before creating size chart
                    console.log('Creating size chart with data:', {
                        small: benchmarks.sizeOfSerializedData.small,
                        big: benchmarks.sizeOfSerializedData.big
                    });

                    const sizeChart = createSizeChart(
                        'sizeComparison',
                        'Serialized Data Size',
                        benchmarks
                    );
                    charts.push(sizeChart);
                } catch (error) {
                    console.error('Error creating charts:', error);
                    errorEl.textContent = 'Error creating charts. Please try again later.';
                    errorEl.style.display = 'block';
                }

                // Handle window resize for all charts
                window.addEventListener('resize', () => {
                    charts.forEach(chart => chart.resize());
                });
            })
            .catch(error => {
                loadingEl.style.display = 'none';
                errorEl.textContent = 'Error loading benchmark data. Please try again later.';
                errorEl.style.display = 'block';
            });
    </script>
</body>
</html>
